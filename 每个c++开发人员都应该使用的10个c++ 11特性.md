> 本文转载自：https://www.codeproject.com/Articles/570638/Ten-Cplusplus11-Features-Every-Cplusplus-Developer
## 目录

- auto
- nullptr
- Range-Based for Loops
- Override and Final
- Strongly-typed Enums
- Smart Pointers
- Lambdas
- Non-Member begin() and end()
- static_assert and Type Traits
- Move Semantics

## auto

在 C++11 之前，`auto`关键字用于存储持续时间规范。在新标准中，其目的改为类型推断。`auto`现在是一种类型的占位符，告诉编译器它必须从其初始值设定项中推断出正在声明的变量的实际类型。它可用于在不同范围内声明变量，例如命名空间、块或`for`循环的初始化语句。

Before C++11, the `auto` keyword was used for storage duration specification. In the new standard, its purpose was changed towards type inference. `auto` is now a sort of placeholder for a type, telling the compiler it has to deduce the actual type of a variable that is being declared from its initializer. It can be used when declaring variables in different scopes such as namespaces, blocks or initialization statement of `for` loops.

```c++
auto i = 42;        // i is an int
auto l = 42LL;      // l is an long long
auto p = new foo(); // p is a foo*
```

使用`auto`通常意味着更少的代码（除非你的类型是`int`短一个字母）。想想 STL 中的迭代器，您在迭代容器时总是必须编写这些迭代器。`typedef`只是为了简单起见，它已经过时了。

Using `auto` usually means less code (unless your type is `int` which is one letter shorter). Think of iterators in STL that you always had to write while iterating over containers. It makes obsolete creating `typedef`s just for the sake of simplicity.

```c++
std::map<std::string, std::vector<int>> map;
for(auto it = begin(map); it != end(map); ++it) 
{
}
```

您应该注意，`auto`不能用作函数的返回类型。但是，您可以使用`auto`代替函数的返回类型，但在这种情况下，函数必须具有尾随返回类型。在这种情况下，`auto`不会告诉编译器它必须推断类型，它只指示它在函数末尾查找返回类型。在下面的示例中，函数`compose`的返回类型是 operator+ 的返回类型，它将类型`T1`和 的值相加`T2`

You should note that `auto` cannot be used as the return type of a function. However, you can use `auto` in place of the return type of function, but in this case the function must have a trailing return type. In this case, `auto` does not tell the compiler it has to infer the type, it only instructs it to look for the return type at the end of the function. In the example below, the return type of function `compose` is the return type of operator+ that sums values of types `T1` and `T2`.

```c++
template <typename T1, typename T2>
auto compose(T1 t1, T2 t2) -> decltype(t1 + t2)
{
   return t1+t2;
}
auto v = compose(2, 3.14); // v's type is double
```

## nullptr

0曾经是`null`指针的值，并且由于隐式转换为整数类型而存在缺陷。关键字`nullptr`表示`std::nullptr_t`表示`null`指针文字的类型值。隐式转换从存在`nullptr`于`null`任何指针类型和任何指针到成员类型的指针值，也能`bool`（如`false`）。但是不存在到整型的隐式转换。

Zero used to be the value of `null` pointers, and that has drawbacks due to the implicit conversion to integral types. The keyword `nullptr` denotes a value of type `std::nullptr_t` that represents the `null` pointer literal. Implicit conversions exists from `nullptr` to `null` pointer value of any pointer type and any pointer-to-member types, but also to `bool` (as `false`). But no implicit conversion to integral types exist.

```c++
void foo(int* p) {}

void bar(std::shared_ptr<int> p) {}

int* p1 = NULL;
int* p2 = nullptr;   
if(p1 == p2)
{
}

foo(nullptr);
bar(nullptr);

bool f = nullptr;
int i = nullptr; // error: A native nullptr can only be converted to bool or, 
                 // using reinterpret_cast, to an integral type
```


为了向后兼容，`0`仍然是一个有效的`null`指针值。
For backward compatibility, `0` is still a valid `null` pointer value.

## 基于范围的循环

C++11 扩充了该`for`语句以支持`foreach`迭代集合的“ ”范式。在新形式中，可以迭代 C 类数组、初始化列表和任何非成员`begin()`和`end()`函数被重载的东西。

`for`当您只想获取和处理集合/数组的元素而不关心索引、迭代器或元素数量时，这对于每个人都很有用。

C++11 augmented the `for` statement to support the "`foreach`" paradigm of iterating over collections. In the new form, it is possible to iterate over C-like arrays, initializer lists and anything for which the non-member `begin()` and `end()` functions are overloaded.

This for each `for` is useful when you just want to get and do something with the elements of a collection/array and don't care about indexes, iterators or number of elements.

```c++
std::map<std::string, std::vector<int>> map;
std::vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
map["one"] = v;

for(const auto& kvp : map) 
{
  std::cout << kvp.first << std::endl;

  for(auto v : kvp.second)
  {
     std::cout << v << std::endl;
  }
}

int arr[] = {1,2,3,4,5};
for(int& e : arr) 
{
  e = e*e;
}
```

## Override 和 Final
我总是发现`virtual`C++ 中的方法设计得很糟糕，因为没有（现在仍然没有）强制机制将`virtual`方法标记为在派生类中被覆盖。该`virtual`关键字是可选的，这让阅读代码有点困难，因为你可能要看看通过层次结构的顶端，以检查方法`virtual`。我一直使用并鼓励人们`virtual`在派生类上也使用关键字，以使代码更易于阅读。但是，仍然可能出现一些细微的错误。以下面的例子为例：

I always found the `virtual` methods badly designed in C++ because there wasn't (and still isn't) a mandatory mechanism to mark `virtual` methods as overridden in derived classes. The `virtual` keyword is optional and that makes reading code a bit harder, because you may have to look through the top of the hierarchy to check if the method is `virtual`. I have always used, and encouraged people to use the `virtual` keyword on derived classes also, to make the code easier to read. However, there are subtle errors that can still arise. Take for instance, the following example:

```c++
class B 
{
public:
   virtual void f(short) {std::cout << "B::f" << std::endl;}
};

class D : public B
{
public:
   virtual void f(int) {std::cout << "D::f" << std::endl;}
};
```

`D::f`应该覆盖`B::f`. 但是，签名不同，一个采用`short`，一个采用`int`，因此`B::f`只是另一种具有相同名称（和重载）的方法，而不是覆盖。您可以`f()`通过指向`B`并期望打印的指针进行调用`D::f`，但它正在打印`B::f`。

这里还有一个微妙的错误：参数相同，但基类中`const`的方法被标记为，而派生中的方法没有。

`D::f` is supposed to override `B::f`. However, the signatures differ, one takes a `short`, one takes an `int`, therefore `B::f` is just another method with the same name (and overload) and not an override. You may call `f()` through a pointer to `B` and expect to print `D::f`, but it's printing `B::f`.

Here is another subtle error: the parameters are the same, but the method in the base class is marked `const`, while the method in the derived is not.

```c++
class B 
{
public:
   virtual void f(int) const {std::cout << "B::f " << std::endl;}
};

class D : public B
{
public:
   virtual void f(int) {std::cout << "D::f" << std::endl;}
};
```

同样，这两个是重载而不是覆盖，因此如果您`f()`通过指向 的指针调用`B`，它将打印`B::f`而不是`D::f`。

幸运的是，现在有一种方法可以描述您的意图。添加了两个新的特殊标识符（不是关键字）：`override`, 指示方法应该覆盖`virtual`基类中的方法，以及`final`，指示派生类不应覆盖`virtual`方法。第一个例子将变成：

Again, these two are overloads and not overrides, so if you call `f()` through a pointer to `B`, it will print `B::f` and not `D::f`.

Fortunately, there is now a way to describe your intentions. Two new special identifiers (not keywords) have been added: `override`, to indicate that a method is supposed to be an override of a `virtual` method in a base class, and `final`, to indicate that a derived class shall not override a `virtual` method. The first example would become:

```c++
class B 
{
public:
   virtual void f(short) {std::cout << "B::f" << std::endl;}
};

class D : public B
{
public:
   virtual void f(int) override {std::cout << "D::f" << std::endl;}
};
```

这现在会触发编译器错误（如果使用说明`override`符，您也会在第二个示例中得到相同的错误）：

This now triggers a compiler error (the same error you'd get for the second example too, if using the `override` specifier):

```c++
'D::f' : method with override specifier 'override' did not override any base class methods
```

另一方面，如果您打算使某个方法无法再被覆盖（在层次结构中），请将其标记为`final`. 这可以在基类或任何派生类中。如果它在派生类中，则可以同时使用 the`override`和`final`说明符。

On the other hand, if you intend to make a method impossible to override any more (down the hierarchy), mark it as `final`. That can be in the base class, or any derived class. If it's in a derived classe, you can use both the `override` and `final` specifiers.

```c++
class B 
{
public:
   virtual void f(int) {std::cout << "B::f" << std::endl;}
};

class D : public B
{
public:
   virtual void f(int) override final {std::cout << "D::f" << std::endl;}
};

class F : public D
{
public:
   virtual void f(int) override {std::cout << "F::f" << std::endl;}
};
```

```c++
function declared as 'final' cannot be overridden by 'F::f'
```

## 强类型枚举

`enum` C++ 中的“传统” s 有一些缺点：它们在周围的作用域中导出它们的枚举器（这会导致名称冲突，如果`enum`同一作用域中的两个不同的s 定义了同名的枚举器），它们会被隐式转换为整数类型并且不能具有用户指定的基础类型。

这些问题已在 C++ 11 中通过引入新的`enum`s类别（称为强类型枚举）得到解决。它们是用`enum class`关键字指定的。它们不再在周围范围内导出其枚举数，不再隐式转换为整数类型，并且可以具有用户指定的基础类型（也为传统`enum`s添加了一项功能）。

"Traditional" `enum`s in C++ have some drawbacks: they export their enumerators in the surrounding scope (which can lead to name collisions, if two different `enum`s in the same have scope define enumerators with the same name), they are implicitly converted to integral types and cannot have a user-specified underlying type.

These issues have been fixed in C++ 11 with the introduction of a new category of `enum`s, called strongly-typed enums. They are specified with the `enum class` keywords. They no longer export their enumerators in the surrounding scope, are no longer implicitly converted to integral types and can have a user-specified underlying type (a feature also added for traditional `enum`s).

```c++
enum class Options {None, One, All};
Options o = Options::All;
```

## 智能指针

已经有很多关于这个主题的文章，因此我只想提到具有引用计数和自动释放可用内存的智能指针：

- unique_ptr：应该在内存资源的所有权不必共享（它没有复制构造函数）但可以转移到另一个`unique_ptr`（移动构造函数存在）时使用。
- shared_ptr：应该在内存资源的所有权应该共享时使用（因此得名）。
- weak_ptr：持有对 a 管理的对象的引用`shared_ptr`，但不影响引用计数；它用于打破依赖循环（想想一棵树，其中父级持有`shared_ptr`对其子级的拥有引用 ( )，但子级也必须持有对父级的引用；如果第二个引用也是拥有者，则循环被创建，并且永远不会释放任何对象）。

另一方面，`auto_ptr`已过时，不应再使用。

何时使用`unique_ptr`以及何时使用`shared_ptr`取决于所有权要求，我建议阅读此讨论。

下面的第一个示例显示`unique_ptr`. 如果您想将一个对象的所有权转让给另一个`unique_ptr`，请使用`std::move`（我将在最后一段中讨论此功能）。所有权转移后，放弃所有权的智能指针变为`null`并`get()`返回`nullptr`。

There have been tons of articles written on this subject, therefore I just want to mention the smart pointers with reference counting and auto releasing of owned memory that are available:

- [unique_ptr](http://en.cppreference.com/w/cpp/memory/unique_ptr): should be used when ownership of a memory resource does not have to be shared (it doesn't have a copy constructor), but it can be transferred to another `unique_ptr` (move constructor exists).
- [shared_ptr](http://en.cppreference.com/w/cpp/memory/shared_ptr): should be used when ownership of a memory resource should be shared (hence the name).
- [weak_ptr](http://en.cppreference.com/w/cpp/memory/weak_ptr): holds a reference to an object managed by a `shared_ptr`, but does not contribute to the reference count; it is used to break dependency cycles (think of a tree where the parent holds an owning reference (`shared_ptr`) to its children, but the children also must hold a reference to the parent; if this second reference was also an owning one, a cycle would be created and no object would ever be released).

On the other hand, the `auto_ptr` is obsolete and should no longer be used.

When you should use `unique_ptr` and when you should use `shared_ptr` depends on the ownership requirements and I recommend reading this [discussion](http://stackoverflow.com/questions/15648844/using-smart-pointers-for-class-members).

The first example below shows `unique_ptr`. If you want to transfer ownership of an object to another `unique_ptr`, use `std::move` (I'll discuss this function in the last paragraph). After the ownership transfer, the smart pointer that ceded the ownership becomes `null` and `get()` returns `nullptr`.

```c++
void foo(int* p)
{
   std::cout << *p << std::endl;
}
std::unique_ptr<int> p1(new int(42));
std::unique_ptr<int> p2 = std::move(p1); // transfer ownership

if(p1)
  foo(p1.get());

(*p2)++;

if(p2)
  foo(p2.get());
```

第二个例子显示`shared_ptr`. 用法类似，但语义不同，因为所有权是共享的。

The second example shows `shared_ptr`. Usage is similar, though the semantics are different since ownership is shared.

```c++
void foo(int* p)
{
}
void bar(std::shared_ptr<int> p)
{
   ++(*p);
}
std::shared_ptr<int> p1(new int(42));
std::shared_ptr<int> p2 = p1;
   
bar(p1);   
foo(p2.get());
```

第一个声明等同于这个声明。
The first declaration is equivalent to this one.

```c++
auto p3 = std::make_shared<int>(42);
```

make_shared是一个非成员函数，具有为共享对象和智能指针分配内存的优点，与`shared_ptr`通过构造函数显式构造 a 不同，它需要至少两次分配。除了可能的开销之外，还可能存在因此而发生内存泄漏的情况。在下一个示例中，如果`seed()`抛出错误，可能会发生内存泄漏。

[make_shared](http://en.cppreference.com/w/cpp/memory/shared_ptr/make_shared) is a non-member function and has the advantage of allocating memory for the shared object and the smart pointer with a single allocation, as opposed to the explicit construction of a `shared_ptr` via the contructor, that requires at least two allocations. In addition to possible overhead, there can be situations where memory leaks can occur because of that. In the next example, memory leaks could occur if `seed()` throws an error.

```c++
void foo(std::shared_ptr<int> p, int init)
{
   *p = init;
}
foo(std::shared_ptr<int>(new int(42)), seed());
```

如果使用`make_shared`. 第三个示例显示了`weak_ptr`. 请注意，为了访问对象，您必须始终`shared_ptr`通过调用`lock()`来获取引用的对象。
No such problem exists if using `make_shared`. The third sample shows usage of `weak_ptr`. Notice that you must always get a `shared_ptr` to the referred object by calling `lock()`, in order to access the object.

```c++
auto p = std::make_shared<int>(42);
std::weak_ptr<int> wp = p;

{
  auto sp = wp.lock();
  std::cout << *sp << std::endl;
}

p.reset();

if(wp.expired())
  std::cout << "expired" << std::endl;
```

如果你试图锁定一个过期`weak_ptr`的对象（对象弱引用已经被释放），你会得到一个空的`shared_ptr`.
If you try to lock on an expired `weak_ptr` (the object is weakly reference has been released), you get an empty `shared_ptr`.

## 匿名函数

匿名函数，称为 lambda，已被添加到 C++ 中并迅速崛起。它是从函数式编程中借用的强大功能，反过来又启用了其他功能或强大的库。您可以在需要函数对象、函子或 a 的任何地方使用 lambda `std::function`。您可以在此处阅读有关语法的信息。

Anonymous functions, called lambda, have been added to C++ and quickly rose to prominence. It is a powerful feature borrowed from functional programming, that in turn enabled other features or powered libraries. You can use lambdas wherever a function object or a functor or a `std::function` is expected. You can read about the syntax [here](http://msdn.microsoft.com/en-us/library/dd293603.aspx).

```c++
std::vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);

std::for_each(std::begin(v), std::end(v), [](int n) {std::cout << n << std::endl;});

auto is_odd = [](int n) {return n%2==1;};
auto pos = std::find_if(std::begin(v), std::end(v), is_odd);
if(pos != std::end(v))
  std::cout << *pos << std::endl;
```

递归 lambda 表达式有点棘手。想象一个代表斐波那契函数的 lambda。如果您尝试使用 编写它`auto`，则会出现编译错误：
A bit trickier are recursive lambdas. Imagine a lambda that represents a Fibonacci function. If you attempt to write it using `auto`, you get a compilation error:

```c++
auto fib = [&fib](int n) {return n < 2 ? 1 : fib(n-1) + fib(n-2);};
```

```c++
error C3533: 'auto &': a parameter cannot have a type that contains 'auto'
error C3531: 'fib': a symbol whose type contains 'auto' must have an initializer
error C3536: 'fib': cannot be used before it is initialized
error C2064: term does not evaluate to a function taking 1 arguments
```

问题是`auto`对象的类型是从它的初始化器推断出来的，但初始化器包含对它的引用，因此需要知道它的类型。这是一个循环问题。关键是打破这种依赖循环并使用`std::function`.

The problem is `auto` means the type of the object is inferred from its initializer, yet the initializer contains a reference to it, therefore needs to know its type. This is a cyclic problem. The key is to break this dependency cycle and explicitly specify the function's type using `std::function`.

```c++
std::function<int(int)> lfib = [&lfib](int n) {return n < 2 ? 1 : lfib(n-1) + lfib(n-2);};
```

## 非成员begin()和end()

您可能注意到我在上面的示例中使用了非成员`begin()`和`end()`函数。这些是标准库的新增内容，可促进统一性、一致性并支持更通用的编程。它们适用于所有 STL 容器，但更重要的是，它们是可重载的，因此它们可以扩展为适用于任何类型。还提供了类 C 数组的重载。

举个例子，前面的例子我打印了一个向量，然后寻找它的第一个奇数元素。如果它`std::vector`是一个类似 C 的数组，则代码可能如下所示：

You probably noticed that I have used in the samples above non-member `begin()` and `end()` functions. These are a new addition to the standard library, promoting uniformity, consistency and enabling more generic programming. They work with all STL containers, but more than that, they are overloadable, so they can be extended to work with any type. Overloads for C-like arrays are also provided.

Let's take, for instance, the previous example where I was printing a vector and then looking for its first odd element. If the `std::vector` was instead a C-like array, the code might have looked like this:

```c++
int arr[] = {1,2,3};
std::for_each(&arr[0], &arr[0]+sizeof(arr)/sizeof(arr[0]), [](int n) 
             {std::cout << n << std::endl;});

auto is_odd = [](int n) {return n%2==1;};
auto begin = &arr[0];
auto end = &arr[0]+sizeof(arr)/sizeof(arr[0]);
auto pos = std::find_if(begin, end, is_odd);
if(pos != end)
  std::cout << *pos << std::endl;
```

对于非成员`begin()`and `end()`，可以这样写：
With non-member `begin()` and `end()`, it could be put as this:

```c++
int arr[] = {1,2,3};
std::for_each(std::begin(arr), std::end(arr), [](int n) {std::cout << n << std::endl;});

auto is_odd = [](int n) {return n%2==1;};
auto pos = std::find_if(std::begin(arr), std::end(arr), is_odd);
if(pos != std::end(arr))
  std::cout << *pos << std::endl;
```

这与`std::vector`版本的代码基本相同。这意味着我们可以为`begin()`和支持的所有类型编写一个通用方法`end()`。
This is basically identical code to the `std::vector` version. That means we can write a single generic method for all types supported by `begin()` and `end()`.

```c++
template <typename Iterator>
void bar(Iterator begin, Iterator end) 
{
   std::for_each(begin, end, [](int n) {std::cout << n << std::endl;});

   auto is_odd = [](int n) {return n%2==1;};
   auto pos = std::find_if(begin, end, is_odd);
   if(pos != end)
      std::cout << *pos << std::endl;
}

template <typename C>
void foo(C c)
{
   bar(std::begin(c), std::end(c));
}

template <typename T, size_t N>
void foo(T(&arr)[N])
{
   bar(std::begin(arr), std::end(arr));
}

int arr[] = {1,2,3};
foo(arr);

std::vector<int> v;
v.push_back(1);
v.push_back(2);
v.push_back(3);
foo(v);
```

## static_assert和Type Traits

`static_assert`在编译时执行断言检查。如果断言是`true`，则什么都不会发生。如果断言为`false`，则编译器显示指定的错误消息。
`static_assert` performs an assertion check at compile-time. If the assertion is `true`, nothing happens. If the assertion is `false`, the compiler displays the specified error message.

```c++
template <typename T, size_t Size>
class Vector
{
   static_assert(Size < 3, "Size is too small");
   T _points[Size];
};

int main()
{
   Vector<int, 16> a1;
   Vector<double, 2> a2;
   return 0;
}
```



```c++
error C2338: Size is too small
see reference to class template instantiation 'Vector<T,Size>' being compiled
   with
   [
      T=double,
      Size=2
   ]
```

`static_assert`与类型特征一起使用时会变得更有用。这些是在编译时提供有关类型信息的一系列类。它们在<type_traits>标头中可用。这个头文件中有几类类：帮助类，用于创建编译时常量，类型特征类，用于在编译时获取类型信息，以及类型转换类，用于通过对现有类型应用转换来获取新类型。

在下面的示例中，函数`add`应该只适用于整数类型。

`static_assert` becomes more useful when used together with type traits. These are a series of classes that provide information about types at compile time. They are available in the [](http://www.cplusplus.com/reference/type_traits/) header. There are several categories of classes in this header: helper classes, for creating compile-time constants, type traits classes, to get type information at compile time, and type transformation classes, for getting new types by applying transformation on existing types.

In the following example, function `add` is supposed to work only with integral types.

```c++
template <typename T1, typename T2>
auto add(T1 t1, T2 t2) -> decltype(t1 + t2)
{
   return t1 + t2;
}
```

但是，如果写入以下内容，则不会出现编译器错误：
However, there are no compiler errors if one writes:

```c++
std::cout << add(1, 3.14) << std::endl;
std::cout << add("one", 2) << std::endl;
```

该程序实际上打印`4.14`和“ `e`”。但是如果我们添加一些编译时断言，这两行都会产生编译器错误：
The program actually prints `4.14` and "`e`". But if we add some compile-time asserts, both these lines would generate compiler errors.

```c++
template <typename T1, typename T2>
auto add(T1 t1, T2 t2) -> decltype(t1 + t2)
{
   static_assert(std::is_integral<T1>::value, "Type T1 must be integral");
   static_assert(std::is_integral<T2>::value, "Type T2 must be integral");

   return t1 + t2;
}
```

```c++
error C2338: Type T2 must be integral
see reference to function template instantiation 'T2 add<int,double>(T1,T2)' being compiled
   with
   [
      T2=double,
      T1=int
   ]
error C2338: Type T1 must be integral
see reference to function template instantiation 'T1 add<const char*,int>(T1,T2)' being compiled
   with
   [
      T1=const char *,
      T2=int
   ]
```

## 转移语义

这是 C++11 中另一个重要且覆盖面很广的主题，人们可以写一系列文章，而不仅仅是一段。因此，我不会涉及太多细节，但如果您还不熟悉该主题，我鼓励您查找其他阅读材料。

C++11 引入了`rvalue`引用的概念（用 指定`&&`）来区分对 an`lvalue`或 an的引用`rvalue`。an`lvalue`是有名字`rvalue`的对象，an是没有名字的对象（临时对象）。移动语义允许修改`rvalue`s（以前被认为是不可变的并且与`const T&`类型无法区分）。

一个 C++ 类/结构曾经有一些隐式成员函数：默认构造函数（仅当另一个构造函数没有明确定义时）和复制构造函数、一个析构函数和一个复制赋值运算符。复制构造函数和复制赋值运算符执行按位（或浅）复制，即按位复制变量。这意味着如果您有一个包含指向某些对象的指针的类，它们只会复制指针的值，而不是它们指向的对象。在某些情况下这可能没问题，但在许多情况下，您实际上需要深度复制，这意味着您想要复制指针所指的对象，而不是指针的值。在这种情况下，您必须显式编写复制构造函数和复制赋值运算符来执行深度复制。

如果您初始化或从中复制的对象是右值（临时对象）怎么办。你仍然需要复制它的值，但在右值消失后不久。这意味着操作的开销，包括分配和内存复制，毕竟不应该是必要的。

输入移动构造函数和移动赋值运算符。这两个特殊函数接受一个 T&& 参数，它是一个`rvalue`. 知道这一事实后，他们可以修改对象，例如“窃取”其指针所指的对象。例如，容器实现（例如向量或队列）可能有一个指向元素数组的指针。当一个对象从一个临时对象实例化时，而不是分配另一个数组，从临时对象复制值，然后在销毁时从临时对象中删除内存，我们只是复制指向分配数组的指针的值，从而保存分配，复制元素序列，以及稍后取消分配。

以下示例显示了一个虚拟缓冲区实现。缓冲区由名称标识（只是为了显示下面显示的点），具有指向`std::unique_ptr`类型`T`和变量的元素数组的指针（包装在 an 中），该变量告诉数组的大小。


This is yet another important and well covered topic from C++11, that one could write a series of articles, not just a paragraph. Therefore, I will not get into too many details, but encourage you to find additional readings, if you're not already familiar with the topic.

C++11 has introduced the concept of `rvalue` references (specified with `&&`) to differentiate a reference to an `lvalue` or an `rvalue`. An `lvalue` is an object that has a name, while an `rvalue` is an object that does not have a name (a temporary object). The move semantics allow modifying `rvalue`s (previously considered immutable and indistinguishable from `const T&` types).

A C++ class/struct used to have some implicit member functions: default constructor (only if another constructor is not explicitly defined) and copy constructor, a destructor and a copy assignment operator. The copy constructor and the copy assignment operator perform a bit-wise (or shallow) copy, i.e., copying the variables bitwise. That means if you have a class that contains pointers to some objects, they just copy the value of the pointers and not the objects they point to. This might be OK in some cases, but for many cases, you actually want a deep-copy, meaning that you want to copy the objects pointers refer to, and not the values of the pointers. In this case, you have to explicitly write copy constructor and copy assignment operator to perform a deep-copy.

What if the object you initialize or copy from is an rvalue (a temporary). You still have to copy its value, but soon after the rvalue goes away. That means an overhead of operations, including allocations and memory copying that after all, should not be necessary.

Enter the move constructor and move assignment operator. These two special functions take a T&& argument, which is an `rvalue`. Knowing that fact, they can modify the object, such as "stealing" the objects their pointers refer to. For instance, a container implementation (such as a vector or a queue) may have a pointer to an array of elements. When an object is instantiating from a temporary, instead of allocating another array, copying the values from the temporary, and then deleting the memory from the temporary when that is destroyed, we just copy the value of the pointer that refers to the allocated array, thus saving an allocation, copying a sequence of elements, and a later de-allocation.

The following example shows a dummy buffer implementation. The buffer is identified by a name (just for the sake of showing a point revealed below), has a pointer (wrapper in an `std::unique_ptr`) to an array of elements of type `T` and variable that tells the size of the array.

```c++
template <typename T>
class Buffer 
{
   std::string          _name;
   size_t               _size;
   std::unique_ptr<T[]> _buffer;

public:
   // default constructor
   Buffer():
      _size(16),
      _buffer(new T[16])
   {}

   // constructor
   Buffer(const std::string& name, size_t size):
      _name(name),
      _size(size),
      _buffer(new T[size])
   {}

   // copy constructor
   Buffer(const Buffer& copy):
      _name(copy._name),
      _size(copy._size),
      _buffer(new T[copy._size])
   {
      T* source = copy._buffer.get();
      T* dest = _buffer.get();
      std::copy(source, source + copy._size, dest);
   }

   // copy assignment operator
   Buffer& operator=(const Buffer& copy)
   {
      if(this != &copy)
      {
         _name = copy._name;

         if(_size != copy._size)
         {
            _buffer = nullptr;
            _size = copy._size;
            _buffer = _size > 0 > new T[_size] : nullptr;
         }

         T* source = copy._buffer.get();
         T* dest = _buffer.get();
         std::copy(source, source + copy._size, dest);
      }

      return *this;
   }

   // move constructor
   Buffer(Buffer&& temp):
      _name(std::move(temp._name)),
      _size(temp._size),
      _buffer(std::move(temp._buffer))
   {
      temp._buffer = nullptr;
      temp._size = 0;
   }

   // move assignment operator
   Buffer& operator=(Buffer&& temp)
   {
      assert(this != &temp); // assert if this is not a temporary

      _buffer = nullptr;
      _size = temp._size;
      _buffer = std::move(temp._buffer);

      _name = std::move(temp._name);

      temp._buffer = nullptr;
      temp._size = 0;
      
      return *this;
   }
};

template <typename T>
Buffer<T> getBuffer(const std::string& name) 
{
   Buffer<T> b(name, 128);
   return b;
}
int main()
{
   Buffer<int> b1;
   Buffer<int> b2("buf2", 64);
   Buffer<int> b3 = b2;
   Buffer<int> b4 = getBuffer<int>("buf4");
   b1 = getBuffer<int>("buf5");
   return 0;
}
```

默认的复制构造函数和复制赋值运算符应该看起来很熟悉。C++11 的新增功能是移动构造函数和移动赋值运算符，它们是按照上述移动语义的精神实现的。如果您运行此代码，您将看到在构造 b4 时，会调用移动构造函数。此外，当`b1`被赋值时，移动赋值运算符被调用。原因是返回的值`getBuffer()`是临时的，即`rvalue`。

在初始化名称变量和指向缓冲区的指针时，您可能注意到在移动构造函数中使用了std::move。名称实际上是 a `string`，并且`std::string`还实现了移动语义。对于`std::unique_ptr`. 但是，如果我们只是说`_name(temp._name)`复制构造函数会被调用。对于`_buffer`，这甚至不可能，因为`std::unique_ptr`它没有复制构造函数。但是为什么`std::string`在这种情况下没有调用移动构造函数呢？因为即使`Buffer`调用移动构造函数的对象是 an `rvalue`，在构造函数内部，它实际上是 an `lvalue`。为什么？因为它有一个名字，" `temp`" 和一个命名对象是一个`lvalue`. 让它再次成为`rvalue`（并且能够调用适当的移动构造函数），必须使用`std::move`. 这个函数只是把一个`lvalue`引用变成一个`rvalue`引用。

**更新**：虽然这个例子的目的是展示移动构造函数和移动赋值运算符应该如何实现，但实现的确切细节可能会有所不同。成员 7805758在评论中提供了替代实现。为了方便大家看，我在这里展示一下：

The default copy constructor and copy assignment operator should look familiar. What's new to C++11 is the move constructor and move assignment operator, implemented in the spirit of the aforementioned move semantics. If you run this code, you'll see that when b4 is constructed, the move constructor is called. Also, when `b1` is assigned a value, the move assignment operator is called. The reason is the value returned by `getBuffer()` is a temporary, i.e., an `rvalue`.

You probably noticed the use of [std::move](http://en.cppreference.com/w/cpp/utility/move) in the move constructor, when initializing the name variable and the pointer to the buffer. The name is actually a `string`, and `std::string` also implements move semantics. Same for the `std::unique_ptr`. However, if we just said `_name(temp._name)` the copy constructor would have been called. For `_buffer`, that would not have been even possible because `std::unique_ptr` does not have a copy constructor. But why wasn't the move constructor for `std::string` called in this case? Because even if the object the move constructor for `Buffer` is called with is an `rvalue`, inside the constructor, it is actually an `lvalue`. Why? Because it has a name, "`temp`" and a named object is an `lvalue`. To make it again an `rvalue` (and be able to invoke the appropriate move constructor), one must use `std::move`. This function just turns an `lvalue` reference into an `rvalue` reference.

**UPDATE**: Though the purpose of this example was to show how move constructor and move assignment operator should be implemented, the exact details of an implementation may vary. An alternative implementation was provided by [Member 7805758](http://www.codeproject.com/script/Membership/View.aspx?mid=7805758) in the comments. To be easier to see it, I will show it here:

```c++
template <typename T>
class Buffer
{
   std::string          _name;
   size_t               _size;
   std::unique_ptr<T[]> _buffer;
 
public:
   // constructor
   Buffer(const std::string& name = "", size_t size = 16):
      _name(name),
      _size(size),
      _buffer(size? new T[size] : nullptr)
   {}
 
   // copy constructor
   Buffer(const Buffer& copy):
      _name(copy._name),
      _size(copy._size),
      _buffer(copy._size? new T[copy._size] : nullptr)
   {
      T* source = copy._buffer.get();
      T* dest = _buffer.get();
      std::copy(source, source + copy._size, dest);
   }
 
   // copy assignment operator
   Buffer& operator=(Buffer copy)
   {
       swap(*this, copy);
       return *this;
   }
 
   // move constructor
   Buffer(Buffer&& temp):Buffer()
   {
      swap(*this, temp);
   }
 
   friend void swap(Buffer& first, Buffer& second) noexcept
   {
       using std::swap;
       swap(first._name  , second._name);
       swap(first._size  , second._size);
       swap(first._buffer, second._buffer);
   }
};
```

## 总结

关于 C++11，还有很多话要说；这只是许多可能的开始之一。本文介绍了每个 C++ 开发人员都应该使用的一系列核心语言和标准库功能。但是，我建议您至少对于其中一些功能而言，还需要阅读其他材料。

There are many more things to say about C++11; this was just one of many possible beginnings. This article presented a series of core language and standard library features that every C++ developer should use. However, I recommend you additional readings, at least for some of these features.
